from app.core.motor_registry import motor_registry, MotorType, MotorVersion, SubscriptionTier
import time
"""
Motor Wrapper v2.1.0 - WITH EMERGENCY FALLBACK
Automatic v1/v2 selection with comprehensive fallback mechanism

PHILOSOPHY:
- Selects correct motor version
- Falls back on error (v2 → v1)
- Emergency fallback (wrapper failure → direct v1)
- Returns result UNTOUCHED in envelope
- NEVER CRASHES

NEW IN v2.1.0:
- Emergency v1 fallback (last resort)
- fallback_reason field (optional, for debug)
- Never crash guarantee

RESPONSIBILITIES:
1. Select motor version (based on tier)
2. Handle v2 errors → silent v1 fallback
3. Handle wrapper errors → emergency v1 fallback
4. Envelope response (data + meta)
5. Minimal error logging

LOCK DATE: 2025-01-02
VERSION: 2.1.0
"""

import logging
from typing import Dict, Optional, List, Any
from enum import Enum


logger = logging.getLogger(__name__)


class UserTier(str, Enum):
    """User subscription tiers"""
    FREE = "free"
    BASIC = "basic"
    MEDIUM = "medium"
    PREMIUM = "premium"
    INSTITUTION = "institution"


class MotorWrapper:
    """
    Motor version orchestration with comprehensive fallback
    
    Fallback Levels:
    1. Normal: v2 → v1 (if v2 fails)
    2. Emergency: Wrapper fail → Direct v1 call
    
    Never crashes guarantee
    """
    
    def __init__(
        self,
        difficulty_v1,
        difficulty_v2,
        bs_model_v1,
        bs_model_v2,
        priority_v1,
        priority_v2,
        time_v1,
        time_v2,
        context_service=None,
        segmentation_engine=None
    ):
        """Initialize with all motor instances"""
        self.difficulty_v1 = difficulty_v1
        self.difficulty_v2 = difficulty_v2
        self.bs_model_v1 = bs_model_v1
        self.bs_model_v2 = bs_model_v2
        self.priority_v1 = priority_v1
        self.priority_v2 = priority_v2
        self.time_v1 = time_v1
        self.time_v2 = time_v2
        self.context_service = context_service
        self.segmentation_engine = segmentation_engine
    
    # ========================================
    # HELPER: v2 ELIGIBILITY CHECK
    # ========================================
    
    @staticmethod
    def _can_use_v2(user_tier: UserTier, *required_fields) -> bool:
        """Check if v2 can be used"""
        tier_eligible = user_tier in [UserTier.PREMIUM, UserTier.INSTITUTION]
        fields_present = all(field is not None for field in required_fields)
        return tier_eligible and fields_present
    
    @staticmethod
    def _envelope_response(
        data: Any,
        motor_version: str,
        fallback_used: bool,
        user_tier: UserTier,
        fallback_reason: Optional[str] = None
    ) -> Dict:
        """
        Wrap motor result in response envelope
        
        Args:
            data: Motor result (untouched)
            motor_version: "v1" or "v2"
            fallback_used: Whether fallback occurred
            user_tier: User tier
            fallback_reason: Why fallback happened (optional, for debug)
        
        Returns:
            Enveloped response
        """
        meta = {
            "motor_version": motor_version,
            "fallback_used": fallback_used,
            "tier": user_tier.value
        }
        
        # Add fallback_reason if present (optional field)
        if fallback_reason:
            meta["fallback_reason"] = fallback_reason
        
        return {
            "data": data,
            "meta": meta
        }
    
    # ========================================
    # DIFFICULTY MOTOR
    # ========================================
    



    def calculate_time(
        self,
        student_id: str,
        topic_id: str,
        user_tier: UserTier
    ) -> dict:
        """Calculate Time/Speed score with v1/v2 selection"""
        
        config = motor_registry.get_motor_config(
            motor_type=MotorType.TIME,
            user_tier=SubscriptionTier(user_tier.value),
            user_id=student_id
        )
        
        start_time = time.time()
        
        try:
            if config.version == MotorVersion.V2:
                result = self.time_v2.calculate(student_id, topic_id, config.__dict__)
            else:
                result = self.time_v1.calculate(student_id, topic_id)
            
            execution_time = (time.time() - start_time) * 1000
            
            motor_registry.log_performance(
                motor_type=MotorType.TIME,
                version=config.version,
                success=True,
                execution_time_ms=execution_time
            )
            
            return {
                "data": result,
                "meta": {
                    "motor_version": config.version.value,
                    "fallback_used": False,
                    "tier": user_tier.value
                }
            }
            
        except Exception as e:
            print(f"Time v2 failed, falling back to v1: {e}")
            result = self.time_v1.calculate(student_id, topic_id)
            
            return {
                "data": result,
                "meta": {
                    "motor_version": "v1",
                    "fallback_used": True,
                    "tier": user_tier.value,
                    "fallback_reason": "v2_exception"
                }
            }

    def calculate_priority(
        self,
        student_id: str,
        topic_id: str,
        test_date: str,
        user_tier: UserTier
    ) -> dict:
        """Calculate Priority score with v1/v2 selection"""
        
        config = motor_registry.get_motor_config(
            motor_type=MotorType.PRIORITY,
            user_tier=SubscriptionTier(user_tier.value),
            user_id=student_id
        )
        
        start_time = time.time()
        
        try:
            if config.version == MotorVersion.V2:
                result = self.priority_v2.calculate(student_id, topic_id, test_date, config.__dict__)
            else:
                result = self.priority_v1.calculate(student_id, topic_id, test_date)
            
            execution_time = (time.time() - start_time) * 1000
            
            motor_registry.log_performance(
                motor_type=MotorType.PRIORITY,
                version=config.version,
                success=True,
                execution_time_ms=execution_time
            )
            
            return {
                "data": result,
                "meta": {
                    "motor_version": config.version.value,
                    "fallback_used": False,
                    "tier": user_tier.value
                }
            }
            
        except Exception as e:
            print(f"Priority v2 failed, falling back to v1: {e}")
            result = self.priority_v1.calculate(student_id, topic_id, test_date)
            
            return {
                "data": result,
                "meta": {
                    "motor_version": "v1",
                    "fallback_used": True,
                    "tier": user_tier.value,
                    "fallback_reason": "v2_exception"
                }
            }

    def calculate_bs_model(
        self,
        input_data,
        student_id: str,
        user_tier: UserTier
    ) -> dict:
        """Calculate BS-Model score with v1/v2 selection"""
        
        config = motor_registry.get_motor_config(
            motor_type=MotorType.BS_MODEL,
            user_tier=SubscriptionTier(user_tier.value),
            user_id=student_id
        )
        
        start_time = time.time()
        
        try:
            if config.version == MotorVersion.V2:
                result = self.bs_model_v2.calculate(
                    input_data=input_data,
                    student_id=student_id,
                    topic_id=input_data.topic_id,
                    analysis_allowed=True,
                    config=None
                )
            else:
                result = self.bs_model_v1.calculate(input_data)
            
            execution_time = (time.time() - start_time) * 1000
            
            motor_registry.log_performance(
                motor_type=MotorType.BS_MODEL,
                version=config.version,
                success=True,
                execution_time_ms=execution_time
            )
            
            return {
                "data": result,
                "meta": {
                    "motor_version": config.version.value,
                    "fallback_used": False,
                    "tier": user_tier.value
                }
            }
            
        except Exception as e:
            print(f"BS-Model v2 failed, falling back to v1: {e}")
            result = self.bs_model_v1.calculate(input_data)
            
            return {
                "data": result,
                "meta": {
                    "motor_version": "v1",
                    "fallback_used": True,
                    "tier": user_tier.value,
                    "fallback_reason": "v2_exception"
                }
            }

    def calculate_difficulty(
        self,
        input_data,
        student_id: Optional[str] = None,
        user_tier: UserTier = UserTier.FREE,
        config: Optional[object] = None
    ) -> Dict:
        """
        Calculate difficulty with automatic v1/v2 selection + emergency fallback
        """
        
        try:
            # Check if v2 available
            if not self._can_use_v2(user_tier, student_id):
                result = self.difficulty_v1.calculate(input_data, config)
                return self._envelope_response(result, "v1", False, user_tier)
            
            # Try v2, fallback to v1 on error
            try:
                result = self.difficulty_v2.calculate(input_data, student_id, config)
                return self._envelope_response(result, "v2", False, user_tier)
            except Exception as e:
                logger.error(f"Difficulty v2 failed, falling back to v1: {e}")
                result = self.difficulty_v1.calculate(input_data, config)
                return self._envelope_response(
                    result, "v1", True, user_tier,
                    fallback_reason="v2_exception"
                )
        
        except Exception as e:
            # EMERGENCY: Wrapper completely failed
            logger.critical(
                f"MotorWrapper.calculate_difficulty failed completely, "
                f"emergency v1 engaged: {e}"
            )
            return self._emergency_v1_difficulty(input_data, config, str(e), user_tier)
    
    # ========================================
    # BS-MODEL MOTOR
    # ========================================
    
