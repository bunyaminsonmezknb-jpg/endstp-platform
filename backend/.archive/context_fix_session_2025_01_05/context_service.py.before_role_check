"""
Context Service
Provides rich context data for v2 motors

Responsibilities:
- Topic metadata (prerequisites, difficulty, archetype)
- Student history (past performance, learning patterns)
- Subject context (curriculum structure)

Used by: v2 motors for enhanced analysis
"""

from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
import logging

from app.db.session import get_supabase_admin

logger = logging.getLogger(__name__)


class ContextService:
    """
    Centralized context provider for v2 motors
    
    Provides:
    - Topic metadata (prerequisites, archetypes)
    - Student history (performance patterns)
    - Subject context (curriculum relationships)
    """
    
    def __init__(self):
        """
        Initialize ContextService with SERVICE ROLE (FORCED).
        Backend service MUST use admin client for RLS bypass.
        NO USER CLIENT ALLOWED.
        """
        # FORCE ADMIN CLIENT - NO OVERRIDE
        self.supabase = get_supabase_admin()
        
        # Admin client verified (production ready)
        
        self._cache = {}
        self._cache_ttl = 300  # 5 minutes
    def get_topic_context(self, topic_id: str) -> Dict[str, Any]:
        """
        Get comprehensive topic context
        
        Returns:
            {
                "topic_id": str,
                "archetype": str,  # "formula_heavy", "concept_based", etc.
                "difficulty_baseline": float,  # 1-10
                "prerequisites": [{"topic_id": str, "strength": float}],
                "common_misconceptions": [str],
                "metadata": {}
            }
        """
        # Check cache
        cache_key = f"topic_context:{topic_id}"
        cached = self._get_from_cache(cache_key)
        if cached:
            return cached
        
        # Fetch from database (if available)
        if True:  # Always use admin client
            try:
                # Get topic info
                topic_result = get_supabase_admin().table("topics").select(
                    "id, code, name_tr, difficulty_level"
                ).eq("id", topic_id).execute()
                
                if not topic_result.data:
                    return self._default_topic_context(topic_id)
                
                topic = topic_result.data[0]
                
                # Get prerequisites
                prereq_result = get_supabase_admin().table("prerequisites").select(
                    "prerequisite_topic_id, strength"
                ).eq("topic_id", topic_id).execute()
                
                context = {
                    "topic_id": topic_id,
                    "code": topic.get("code"),
                    "name": topic.get("name_tr"),
                    "archetype": self._infer_archetype(topic),
                    "difficulty_baseline": float(topic.get("difficulty_level", 5)),
                    "prerequisites": [
                        {
                            "topic_id": p["prerequisite_topic_id"],
                            "strength": float(p.get("strength", 0.5))
                        }
                        for p in prereq_result.data
                    ] if prereq_result.data else [],
                    "common_misconceptions": [],  # TODO: Add when data available
                    "metadata": {}
                }
                
                # Cache it
                self._set_cache(cache_key, context)
                return context
                
            except Exception as e:
                logger.error(f"Error fetching topic context: {e}")
                return self._default_topic_context(topic_id)
        
        # No database, return default
        return self._default_topic_context(topic_id)
    
    def _infer_archetype(self, topic: Dict) -> str:
        """Infer topic archetype from metadata"""
        # TODO: Enhance with ML or manual tagging
        code = topic.get("code", "").lower()
        
        if any(x in code for x in ["form", "denk", "hesap"]):
            return "formula_heavy"
        elif any(x in code for x in ["kav", "teor", "ilke"]):
            return "concept_based"
        elif any(x in code for x in ["prob", "soru", "Ã¶rnek"]):
            return "problem_solving"
        else:
            return "mixed"
    
    def _default_topic_context(self, topic_id: str) -> Dict[str, Any]:
        """Default context when data unavailable"""
        return {
            "topic_id": topic_id,
            "archetype": "mixed",
            "difficulty_baseline": 5.0,
            "prerequisites": [],
            "common_misconceptions": [],
            "metadata": {"fallback": True}
        }
    
    # ========================================
    # STUDENT HISTORY
    # ========================================
    
    def get_student_history(
        self,
        student_id: str,
        topic_id: Optional[str] = None,
        days_back: int = 30
    ) -> Dict[str, Any]:
        """
        Get student's learning history
        
        Returns:
            {
                "student_id": str,
                "topic_id": str (if specified),
                "test_count": int,
                "avg_success_rate": float,
                "trend": str,  # "improving", "declining", "stable"
                "last_test_date": str (ISO),
                "study_patterns": {
                    "preferred_time": str,
                    "session_length_avg": int
                }
            }
        """
        cache_key = f"student_history:{student_id}:{topic_id}:{days_back}"
        cached = self._get_from_cache(cache_key)
        if cached:
            return cached
        
        if True:  # Always use admin client
            try:
                # Build query
                query = get_supabase_admin().table("topic_test_results").select(
                    "questions_correct, questions_total, time_spent_seconds, entry_timestamp"
                ).eq("user_id", student_id)
                
                if topic_id:
                    query = query.eq("topic_id", topic_id)
                
                # Date filter
                cutoff_date = (datetime.now() - timedelta(days=days_back)).isoformat()
                query = query.gte("entry_timestamp", cutoff_date)
                
                result = query.execute()
                
                if not result.data:
                    return self._default_student_history(student_id, topic_id)
                
                # Calculate metrics
                tests = result.data
                test_count = len(tests)
                
                success_rates = [
                    (t["questions_correct"] / t["questions_total"] * 100)
                    if t["questions_total"] > 0 else 0
                    for t in tests
                ]
                
                avg_success = sum(success_rates) / len(success_rates) if success_rates else 0
                
                # Trend analysis (simple: last 5 vs first 5)
                trend = "stable"
                if test_count >= 10:
                    recent_avg = sum(success_rates[-5:]) / 5
                    old_avg = sum(success_rates[:5]) / 5
                    
                    if recent_avg > old_avg + 10:
                        trend = "improving"
                    elif recent_avg < old_avg - 10:
                        trend = "declining"
                
                history = {
                    "student_id": student_id,
                    "topic_id": topic_id,
                    "test_count": test_count,
                    "avg_success_rate": round(avg_success, 2),
                    "trend": trend,
                    "last_test_date": tests[-1]["entry_timestamp"] if tests else None,
                    "study_patterns": {
                        "session_length_avg": int(sum(t["time_spent_seconds"] for t in tests) / len(tests)),
                        "preferred_time": "afternoon"  # TODO: Analyze timestamps
                    }
                }
                
                self._set_cache(cache_key, history)
                return history
                
            except Exception as e:
                logger.error(f"Error fetching student history: {e}")
                return self._default_student_history(student_id, topic_id)
        
        return self._default_student_history(student_id, topic_id)
    
    def _default_student_history(self, student_id: str, topic_id: Optional[str]) -> Dict:
        """Default history when data unavailable"""
        return {
            "student_id": student_id,
            "topic_id": topic_id,
            "test_count": 0,
            "avg_success_rate": 0.0,
            "trend": "unknown",
            "last_test_date": None,
            "study_patterns": {},
            "metadata": {"fallback": True}
        }
    
    # ========================================
    # SUBJECT CONTEXT
    # ========================================
    
    def get_subject_context(self, subject_code: str) -> Dict[str, Any]:
        """
        Get subject-level context
        
        Returns:
            {
                "subject_code": str,
                "name": str,
                "total_topics": int,
                "difficulty_distribution": {},
                "exam_weight": float
            }
        """
        # Simple implementation for now
        return {
            "subject_code": subject_code,
            "name": subject_code.upper(),
            "total_topics": 50,  # Placeholder
            "difficulty_distribution": {},
            "exam_weight": 1.0
        }
    
    # ========================================
    # CACHE HELPERS
    # ========================================
    
    def _get_from_cache(self, key: str) -> Optional[Dict]:
        """Get from cache if not expired"""
        if key in self._cache:
            value, timestamp = self._cache[key]
            if (datetime.now() - timestamp).seconds < self._cache_ttl:
                return value
            else:
                del self._cache[key]
        return None
    
    def _set_cache(self, key: str, value: Dict):
        """Set cache with timestamp"""
        self._cache[key] = (value, datetime.now())
    

    def get_prerequisites(self, topic_id: str) -> List[Dict]:
        """
        Get prerequisite topics for a given topic
        Returns list of prerequisite topics with their strength
        """
        cache_key = f"prerequisites:{topic_id}"


# ========================================
# FASTAPI DEPENDENCY
# ========================================

def get_context_service_for_user(current_user: dict) -> ContextService:
    """
    FastAPI Dependency: Request-scoped context service
    Creates context service with user's own Supabase client (RLS enforced)
    """
    
    # Using self.supabase (admin client)
    return ContextService(supabase_client=user_supabase)


# ========================================
# FASTAPI DEPENDENCY
# ========================================

